package lang

import (
	"errors"
	"fmt"
	"math"
	"os"
	"reflect"
)

/******************************************************************************
 * The interpreter is responsible for executing the source code. It takes in
 * the AST generated by the parser and checked by the resolver and "walks"
 * over it. Hence why this is referred to as a tree-walk interpreter. This is
 * where the code comes to life.
 *****************************************************************************/

type Interpreter struct {
	globals      *environment
	env          *environment
	locals       map[int]int
	errorHandler *ErrorHandler
}

func NewInterpreter(errorHandler *ErrorHandler) *Interpreter {
	globals := newEnvironment(errorHandler)
	return &Interpreter{globals: globals, env: globals, locals: make(map[int]int),
		errorHandler: errorHandler}
}

func (interpreter *Interpreter) Interpret(statements []Stmt) {
	defer func() {
		err := recover()
		if err != nil {
			/******************************************************************
			 * Gracefully print runtime errors to stderr and return from the
			 * function. Handling runtime errors in this deferred function
			 * allows us to exit the application with the runtime error exit
			 * code (70).
			 *****************************************************************/
			runtimeError, isRuntimeError := err.(runtimeError)
			if isRuntimeError {
				os.Stderr.WriteString(runtimeError.msg)
			} else {
				// this is not a panic thrown by us - pass it on
				panic(err)
			}
		}
	}()

	interpreter.defineNativeFunctions()
	for _, statement := range statements {
		interpreter.execute(statement)
	}
}

func (interpreter *Interpreter) resolve(expr Expr, depth int) {
	interpreter.locals[expr.getId()] = depth
}

func (interpreter *Interpreter) lookUpVariable(name Token, expr Expr) any {
	distance, hasDistance := interpreter.locals[expr.getId()]
	// resolved only local variables so if there is no distance, check the global map
	if hasDistance {
		return interpreter.env.getAt(distance, name)
	} else {
		return interpreter.globals.get(name)
	}
}

func (interperter *Interpreter) defineNativeFunctions() {
	interperter.globals.define("clock", clock{})
}

func (interpreter *Interpreter) executeBlock(statements []Stmt, blockEnv *environment) {
	previousEnv := interpreter.env
	defer func() {
		/**********************************************************************
		 * Always set the environment back to the previous environment before
		 * we exit the function. This is needed so it gets hit even if there
		 * is a return statement or a runtime error occurs in the block.
		 *********************************************************************/
		interpreter.env = previousEnv
	}()
	interpreter.env = blockEnv
	for _, statement := range statements {
		interpreter.execute(statement)
	}
}

func (interpreter *Interpreter) execute(stmt Stmt) any {
	return stmt.accept(interpreter)
}

func (interpreter *Interpreter) evaluate(expr Expr) any {
	return expr.accept(interpreter)
}

func (interpreter *Interpreter) visitBlockStmt(stmt BlockStmt) any {
	interpreter.executeBlock(stmt.statements, newChildEnvironment(interpreter.env))
	return nil
}

func (interpreter *Interpreter) visitClassStmt(stmt ClassStmt) any {
	var superclass *class
	if stmt.superclass.getId() != 0 { // any Expr with an ID of 0 is unitialized
		class, isClass := interpreter.evaluate(stmt.superclass).(class)
		if !isClass {
			err := errors.New("Superclass must be a class.")
			interpreter.errorHandler.reportRuntimeError(stmt.superclass.name.line, err)
		}
		superclass = &class
	}
	interpreter.env.define(stmt.name.lexeme, nil)
	if stmt.superclass.getId() != 0 {
		interpreter.env = newChildEnvironment(interpreter.env)
		interpreter.env.define("super", superclass)
	}
	methods := make(map[string]function)
	for _, method := range stmt.methods {
		methods[method.name.lexeme] = function{declaration: method, closure: interpreter.env,
			isInitializer: method.name.lexeme == "init"}
	}
	class := class{name: stmt.name.lexeme, superclass: superclass, methods: methods,
		errorHandler: interpreter.errorHandler}
	if stmt.superclass.getId() != 0 {
		interpreter.env = interpreter.env.enclosing
	}
	interpreter.env.assign(stmt.name, class)
	return nil
}

func (interpreter *Interpreter) visitExprStmt(stmt ExprStmt) any {
	interpreter.evaluate(stmt.expr)
	return nil
}

func (interpreter *Interpreter) visitFunctionStmt(stmt FunctionStmt) any {
	function := function{declaration: stmt, closure: interpreter.env, isInitializer: false}
	interpreter.env.define(stmt.name.lexeme, function)
	return nil
}

func (interpreter *Interpreter) visitIfStmt(stmt IfStmt) any {
	if isTruthy(interpreter.evaluate(stmt.condition)) {
		interpreter.execute(stmt.thenBranch)
	} else if stmt.elseBranch != nil {
		interpreter.execute(stmt.elseBranch)
	}
	return nil
}

func (interpreter *Interpreter) visitPrintStmt(stmt PrintStmt) any {
	value := interpreter.evaluate(stmt.expr)
	fmt.Println(stringify(value))
	return nil
}

func (interpreter *Interpreter) visitReturnStmt(stmt ReturnStmt) any {
	var value any
	if stmt.value != nil {
		value = interpreter.evaluate(stmt.value)
	}

	// this is a hack to unwind the call stack
	panic(returnContent{value: value})
}

func (interpreter *Interpreter) visitVarStmt(stmt VarStmt) any {
	var value any // set variable value to nil if not explicitly initialized
	if stmt.initializer != nil {
		value = interpreter.evaluate(stmt.initializer)
	}
	interpreter.env.define(stmt.name.lexeme, value)
	return nil
}

func (interpreter *Interpreter) visitWhileStmt(stmt WhileStmt) any {
	for isTruthy(interpreter.evaluate(stmt.condition)) {
		interpreter.execute(stmt.body)
	}
	return nil
}

func (interpreter *Interpreter) visitAssignExpr(expr AssignExpr) any {
	value := interpreter.evaluate(expr.value)
	distance, hasDistance := interpreter.locals[expr.getId()]
	if hasDistance {
		interpreter.env.assignAt(distance, expr.name, value)
	} else {
		interpreter.env.assign(expr.name, value)
	}
	return value
}

func (interpreter *Interpreter) visitBinaryExpr(expr BinaryExpr) any {
	left := interpreter.evaluate(expr.left)
	right := interpreter.evaluate(expr.right)

	switch expr.operator.tokenType {
	case tokenTypeGreater:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '>' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat > rightFloat
	case tokenTypeGreaterEqual:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '>=' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat >= rightFloat
	case tokenTypeLess:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '<' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat < rightFloat
	case tokenTypeLessEqual:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '<=' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat <= rightFloat
	case tokenTypeMinus:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '-' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat - rightFloat
	case tokenTypePlus:
		validFloats, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if validFloats {
			return leftFloat + rightFloat
		}
		validStrings, leftString, rightString := areValuesValidStrings(left, right)
		if validStrings {
			return leftString + rightString
		}
		err := errors.New("Operands must be numbers or strings and be the same type when using the '+' operator.")
		interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
	case tokenTypeSlash:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '/' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat / rightFloat
	case tokenTypeStar:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '*' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat * rightFloat
	case tokenTypeMod:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '%' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		// using math.Mod instead of '%' to handle floating point numbers correctly
		return math.Mod(leftFloat, rightFloat)
	case tokenTypeEqualEqual:
		return reflect.DeepEqual(left, right)
	case tokenTypeBangEqual:
		return !reflect.DeepEqual(left, right)
	}

	// unreachable
	return nil
}

func (interpreter *Interpreter) visitCallExpr(expr CallExpr) any {
	callee := interpreter.evaluate(expr.callee)

	args := make([]any, 0, 0)
	for _, arg := range expr.args {
		args = append(args, interpreter.evaluate(arg))
	}

	callable, isCallable := callee.(callable)
	if isCallable {
		if len(args) != callable.arity() {
			err := errors.New(fmt.Sprintf("Expected %d arguments but got %d.", callable.arity(), len(args)))
			interpreter.errorHandler.reportRuntimeError(expr.paren.line, err)
			return nil
		}
		return callable.call(interpreter, args)
	} else {
		err := errors.New("Can only call functions and classes.")
		interpreter.errorHandler.reportRuntimeError(expr.paren.line, err)
		return nil
	}
}

func (interpreter *Interpreter) visitGetExpr(expr GetExpr) any {
	object, isInstance := interpreter.evaluate(expr.object).(instance)
	if isInstance {
		return object.get(expr.name)
	}
	err := errors.New("Only instances have properties.")
	interpreter.errorHandler.reportRuntimeError(expr.name.line, err)
	return nil
}

func (interpreter *Interpreter) visitGroupingExpr(expr GroupingExpr) any {
	value := interpreter.evaluate(expr.expression)
	return value
}

func (interperter *Interpreter) visitLiteralExpr(expr LiteralExpr) any {
	return expr.value
}

func (interperter *Interpreter) visitLogicalExpr(expr LogicalExpr) any {
	// check if we can short circuit by evaluating left operand first
	left := interperter.evaluate(expr.left)
	if expr.operator.tokenType == tokenTypeOr {
		if isTruthy(left) {
			return left
		}
	} else {
		if !isTruthy(left) {
			return left
		}
	}
	return interperter.evaluate(expr.right)
}

func (interpreter *Interpreter) visitSetExpr(expr SetExpr) any {
	object, isInstance := interpreter.evaluate(expr.object).(instance)
	if !isInstance {
		err := errors.New("Only instances have fields.")
		interpreter.errorHandler.reportRuntimeError(expr.name.line, err)
		return nil
	}
	value := interpreter.evaluate(expr.value)
	object.set(expr.name, value)
	return value
}

func (interpreter *Interpreter) visitSuperExpr(expr SuperExpr) any {
	distance := interpreter.locals[expr.getId()]
	superclass := interpreter.env.getAt(distance, expr.keyword).(*class)
	object := interpreter.env.getSubClassThisValue(distance).(instance)
	method, foundMethod := superclass.findMethod(expr.method.lexeme).(function)
	if !foundMethod {
		err := errors.New("Undefined property '" + expr.method.lexeme + "'.")
		interpreter.errorHandler.reportRuntimeError(expr.method.line, err)
		return nil
	}
	return method.bind(object)
}

func (interpreter *Interpreter) visitThisExpr(expr ThisExpr) any {
	return interpreter.lookUpVariable(expr.keyword, expr)
}

func (interpreter *Interpreter) visitUnaryExpr(expr UnaryExpr) any {
	right := interpreter.evaluate(expr.right)
	switch expr.operator.tokenType {
	case tokenTypeBang:
		return !isTruthy(right)
	case tokenTypeMinus:
		rightFloat, rightFloatValid := right.(float64)
		if !rightFloatValid {
			err := errors.New("Operand must be a number.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return -1 * rightFloat
	}
	return nil
}

func (interpreter *Interpreter) visitVariableExpr(expr VariableExpr) any {
	return interpreter.lookUpVariable(expr.name, expr)
}

func areValuesValidFloats(left, right any) (bool, float64, float64) {
	leftFloat, leftFloatValid := left.(float64)
	rightFloat, rightFloatValid := right.(float64)
	return leftFloatValid && rightFloatValid, leftFloat, rightFloat
}

func areValuesValidStrings(left, right any) (bool, string, string) {
	leftString, leftStringValid := left.(string)
	rightString, rightStringValid := right.(string)
	return leftStringValid && rightStringValid, leftString, rightString
}

func isTruthy(value any) bool {
	if value == nil {
		return false
	}
	boolVal, isBool := value.(bool)
	if isBool {
		return boolVal
	}
	strVal, isString := value.(string)
	if isString {
		return len(strVal) > 0
	}
	number, isNumber := value.(float64)
	if isNumber {
		return -1e-9 > number || number > 1e-9
	}
	return false
}

func stringify(value any) string {
	if value == nil {
		return "nil"
	}
	callable, isCallable := value.(callable)
	if isCallable {
		return callable.toString()
	}
	instance, isInstance := value.(instance)
	if isInstance {
		return instance.toString()
	}
	return fmt.Sprint(value)
}
