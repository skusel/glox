package lang

import (
	"errors"
	"fmt"
	"reflect"
)

/******************************************************************************
 * The interpreter is responsible for executing the source code. It takes in
 * the AST generated by the parser and "walks" over it. Hence why this is a
 * tree-walk interpreter. This is where the code comes to life.
 *****************************************************************************/

type Interpreter struct {
	env          *environment
	errorHandler *ErrorHandler
}

func NewInterpreter(errorHandler *ErrorHandler) *Interpreter {
	return &Interpreter{env: newEnvironment(errorHandler), errorHandler: errorHandler}
}

func (interperter *Interpreter) Interpret(statements []Stmt) {
	for _, statement := range statements {
		if interperter.errorHandler.HadRuntimeError {
			break
		}
		interperter.execute(statement)
	}
}

func (interpreter *Interpreter) executeBlock(statements []Stmt, blockEnv *environment) {
	parentEnv := interpreter.env
	interpreter.env = blockEnv
	for _, statement := range statements {
		interpreter.execute(statement)
		if interpreter.errorHandler.HadRuntimeError {
			break
		}
	}
	interpreter.env = parentEnv
}

func (interpreter *Interpreter) execute(stmt Stmt) any {
	return stmt.accept(interpreter)
}

func (interpreter *Interpreter) evaluate(expr Expr) any {
	return expr.accept(interpreter)
}

func (interpreter *Interpreter) visitBlockStmt(stmt BlockStmt) any {
	interpreter.executeBlock(stmt.statements, newChildEnvironment(interpreter.env))
	return nil
}

func (interpreter *Interpreter) visitExprStmt(stmt ExprStmt) any {
	interpreter.evaluate(stmt.expr)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if statement expression has runtime error
	}
	return nil
}

func (interpreter *Interpreter) visitPrintStmt(stmt PrintStmt) any {
	value := interpreter.evaluate(stmt.expr)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if print expression has runtime error
	}
	fmt.Println(stringify(value))
	return nil
}

func (interpreter *Interpreter) visitVarStmt(stmt VarStmt) any {
	var value any // set variable value to nil if not explicitly initialized
	if stmt.initializer != nil {
		value = interpreter.evaluate(stmt.initializer)
		if interpreter.errorHandler.HadRuntimeError {
			return nil // return immediately if variable init expression has runtime error
		}
	}
	interpreter.env.define(stmt.name.lexeme, value)
	return nil
}

func (interpreter *Interpreter) visitAssignExpr(expr AssignExpr) any {
	value := interpreter.evaluate(expr.value)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if assignment expression has runtime error
	}
	interpreter.env.assign(expr.name, value)
	return value
}

func (interpreter *Interpreter) visitBinaryExpr(expr BinaryExpr) any {
	left := interpreter.evaluate(expr.left)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if left expression has runtime error
	}
	right := interpreter.evaluate(expr.right)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if right expression has runtime error
	}

	switch expr.operator.tokenType {
	case tokenTypeGreater:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '>' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat > rightFloat
	case tokenTypeGreaterEqual:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '>=' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat >= rightFloat
	case tokenTypeLess:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '<' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat < rightFloat
	case tokenTypeLessEqual:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '<=' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat <= rightFloat
	case tokenTypeMinus:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '-' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat - rightFloat
	case tokenTypePlus:
		validFloats, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if validFloats {
			return leftFloat + rightFloat
		}
		validStrings, leftString, rightString := areValuesValidStrings(left, right)
		if validStrings {
			return leftString + rightString
		}
		err := errors.New("Operands must be numbers or strings and be the same type when using the '+' operator.")
		interpreter.errorHandler.reportRuntime(expr.operator.line, err)
	case tokenTypeSlash:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '/' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat / rightFloat
	case tokenTypeStar:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '*' operator.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return leftFloat * rightFloat
	case tokenTypeEqualEqual:
		return reflect.DeepEqual(left, right)
	case tokenTypeBangEqual:
		return !reflect.DeepEqual(left, right)
	}

	// unreachable
	return nil
}

func (interpreter *Interpreter) visitGroupingExpr(expr GroupingExpr) any {
	value := interpreter.evaluate(expr.expression)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if group expression has runtime error
	}
	return value
}

func (interperter *Interpreter) visitLiteralExpr(expr LiteralExpr) any {
	return expr.value
}

func (interpreter *Interpreter) visitUnaryExpr(expr UnaryExpr) any {
	right := interpreter.evaluate(expr.right)
	if interpreter.errorHandler.HadRuntimeError {
		return nil // return immediately if unary expression has runtime error
	}
	switch expr.operator.tokenType {
	case tokenTypeBang:
		return !isTruthy(right)
	case tokenTypeMinus:
		rightFloat, rightFloatValid := right.(float64)
		if !rightFloatValid {
			err := errors.New("Operand must be a number.")
			interpreter.errorHandler.reportRuntime(expr.operator.line, err)
		}
		return -1 * rightFloat
	}
	return nil
}

func (interpreter *Interpreter) visitVariableExpr(expr VariableExpr) any {
	return interpreter.env.get(expr.name)
}

func areValuesValidFloats(left, right any) (bool, float64, float64) {
	leftFloat, leftFloatValid := left.(float64)
	rightFloat, rightFloatValid := right.(float64)
	return leftFloatValid && rightFloatValid, leftFloat, rightFloat
}

func areValuesValidStrings(left, right any) (bool, string, string) {
	leftString, leftStringValid := left.(string)
	rightString, rightStringValid := right.(string)
	return leftStringValid && rightStringValid, leftString, rightString
}

func isTruthy(value any) bool {
	if value == nil {
		return false
	}
	boolVal, isBool := value.(bool)
	if isBool {
		return boolVal
	}
	return false
}

func stringify(value any) string {
	if value == nil {
		return "nil"
	}
	return fmt.Sprint(value)
}
