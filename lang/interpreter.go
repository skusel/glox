package lang

import (
	"errors"
	"fmt"
	"os"
	"reflect"
)

/******************************************************************************
 * The interpreter is responsible for executing the source code. It takes in
 * the AST generated by the parser and "walks" over it. Hence why this is a
 * tree-walk interpreter. This is where the code comes to life.
 *****************************************************************************/

type Interpreter struct {
	globals      *environment
	env          *environment
	errorHandler *ErrorHandler
}

func NewInterpreter(errorHandler *ErrorHandler) *Interpreter {
	globals := newEnvironment(errorHandler)
	return &Interpreter{globals: globals, env: globals, errorHandler: errorHandler}
}

func (interpreter *Interpreter) Interpret(statements []Stmt) {
	defer func() {
		err := recover()
		if err != nil {
			/******************************************************************
			 * Gracefully print runtime errors to stderr and return from the
			 * function. Handling runtime errors in this deferred function
			 * allows us to exit the application with the runtime error exit
			 * code (70).
			 *****************************************************************/
			runtimeError, isRuntimeError := err.(runtimeError)
			if isRuntimeError {
				os.Stderr.WriteString(runtimeError.msg)
			} else {
				// this is not a panic thrown by us - pass it on
				panic(err)
			}
		}
	}()

	interpreter.defineNativeFunctions()
	for _, statement := range statements {
		interpreter.execute(statement)
	}
}

func (interperter *Interpreter) defineNativeFunctions() {
	interperter.globals.define("clock", clock{})
}

func (interpreter *Interpreter) executeBlock(statements []Stmt, blockEnv *environment) {
	previousEnv := interpreter.env
	defer func() {
		/**********************************************************************
		 * Always set the environment back to the previous environment before
		 * we exit the function. This is needed so it gets hit even if there
		 * is a return statement or a runtime error occurs in the block.
		 *********************************************************************/
		interpreter.env = previousEnv
	}()
	interpreter.env = blockEnv
	for _, statement := range statements {
		interpreter.execute(statement)
	}
}

func (interpreter *Interpreter) execute(stmt Stmt) any {
	return stmt.accept(interpreter)
}

func (interpreter *Interpreter) evaluate(expr Expr) any {
	return expr.accept(interpreter)
}

func (interpreter *Interpreter) visitBlockStmt(stmt BlockStmt) any {
	interpreter.executeBlock(stmt.statements, newChildEnvironment(interpreter.env))
	return nil
}

func (interpreter *Interpreter) visitExprStmt(stmt ExprStmt) any {
	interpreter.evaluate(stmt.expr)
	return nil
}

func (interpreter *Interpreter) visitFunctionStmt(stmt FunctionStmt) any {
	function := function{declaration: stmt, closure: interpreter.env}
	interpreter.env.define(stmt.name.lexeme, function)
	return nil
}

func (interpreter *Interpreter) visitIfStmt(stmt IfStmt) any {
	if isTruthy(interpreter.evaluate(stmt.condition)) {
		interpreter.execute(stmt.thenBranch)
	} else if stmt.elseBranch != nil {
		interpreter.execute(stmt.elseBranch)
	}
	return nil
}

func (interpreter *Interpreter) visitPrintStmt(stmt PrintStmt) any {
	value := interpreter.evaluate(stmt.expr)
	fmt.Println(stringify(value))
	return nil
}

func (interpreter *Interpreter) visitReturnStmt(stmt ReturnStmt) any {
	var value any
	if stmt.value != nil {
		value = interpreter.evaluate(stmt.value)
	}

	// this is a hack to unwind the call stack
	panic(returnContent{value: value})
}

func (interpreter *Interpreter) visitVarStmt(stmt VarStmt) any {
	var value any // set variable value to nil if not explicitly initialized
	if stmt.initializer != nil {
		value = interpreter.evaluate(stmt.initializer)
	}
	interpreter.env.define(stmt.name.lexeme, value)
	return nil
}

func (interpreter *Interpreter) visitWhileStmt(stmt WhileStmt) any {
	for isTruthy(interpreter.evaluate(stmt.condition)) {
		interpreter.execute(stmt.body)
	}
	return nil
}

func (interpreter *Interpreter) visitAssignExpr(expr AssignExpr) any {
	value := interpreter.evaluate(expr.value)
	interpreter.env.assign(expr.name, value)
	return value
}

func (interpreter *Interpreter) visitBinaryExpr(expr BinaryExpr) any {
	left := interpreter.evaluate(expr.left)
	right := interpreter.evaluate(expr.right)

	switch expr.operator.tokenType {
	case tokenTypeGreater:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '>' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat > rightFloat
	case tokenTypeGreaterEqual:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '>=' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat >= rightFloat
	case tokenTypeLess:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '<' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat < rightFloat
	case tokenTypeLessEqual:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '<=' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat <= rightFloat
	case tokenTypeMinus:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '-' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat - rightFloat
	case tokenTypePlus:
		validFloats, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if validFloats {
			return leftFloat + rightFloat
		}
		validStrings, leftString, rightString := areValuesValidStrings(left, right)
		if validStrings {
			return leftString + rightString
		}
		err := errors.New("Operands must be numbers or strings and be the same type when using the '+' operator.")
		interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
	case tokenTypeSlash:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '/' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat / rightFloat
	case tokenTypeStar:
		valid, leftFloat, rightFloat := areValuesValidFloats(left, right)
		if !valid {
			err := errors.New("Operands must be numbers when using the '*' operator.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return leftFloat * rightFloat
	case tokenTypeEqualEqual:
		return reflect.DeepEqual(left, right)
	case tokenTypeBangEqual:
		return !reflect.DeepEqual(left, right)
	}

	// unreachable
	return nil
}

func (interpreter *Interpreter) visitCallExpr(expr CallExpr) any {
	callee := interpreter.evaluate(expr.callee)

	args := make([]any, 0, 0)
	for _, arg := range expr.args {
		args = append(args, interpreter.evaluate(arg))
	}

	function, isFunction := callee.(callable)
	if isFunction {
		if len(args) != function.arity() {
			err := errors.New(fmt.Sprintf("Expected %d arguments but got %d.", function.arity(), len(args)))
			interpreter.errorHandler.reportRuntimeError(expr.paren.line, err)
			return nil
		}
		return function.call(interpreter, args)
	} else {
		err := errors.New("Can only call functions and classes.")
		interpreter.errorHandler.reportRuntimeError(expr.paren.line, err)
		return nil
	}
}

func (interpreter *Interpreter) visitGroupingExpr(expr GroupingExpr) any {
	value := interpreter.evaluate(expr.expression)
	return value
}

func (interperter *Interpreter) visitLiteralExpr(expr LiteralExpr) any {
	return expr.value
}

func (interperter *Interpreter) visitLogicalExpr(expr LogicalExpr) any {
	// check if we can short circuit by evaluating left operand first
	left := interperter.evaluate(expr.left)
	if expr.operator.tokenType == tokenTypeOr {
		if isTruthy(left) {
			return left
		}
	} else {
		if !isTruthy(left) {
			return left
		}
	}
	return interperter.evaluate(expr.right)
}

func (interpreter *Interpreter) visitUnaryExpr(expr UnaryExpr) any {
	right := interpreter.evaluate(expr.right)
	switch expr.operator.tokenType {
	case tokenTypeBang:
		return !isTruthy(right)
	case tokenTypeMinus:
		rightFloat, rightFloatValid := right.(float64)
		if !rightFloatValid {
			err := errors.New("Operand must be a number.")
			interpreter.errorHandler.reportRuntimeError(expr.operator.line, err)
		}
		return -1 * rightFloat
	}
	return nil
}

func (interpreter *Interpreter) visitVariableExpr(expr VariableExpr) any {
	return interpreter.env.get(expr.name)
}

func areValuesValidFloats(left, right any) (bool, float64, float64) {
	leftFloat, leftFloatValid := left.(float64)
	rightFloat, rightFloatValid := right.(float64)
	return leftFloatValid && rightFloatValid, leftFloat, rightFloat
}

func areValuesValidStrings(left, right any) (bool, string, string) {
	leftString, leftStringValid := left.(string)
	rightString, rightStringValid := right.(string)
	return leftStringValid && rightStringValid, leftString, rightString
}

func isTruthy(value any) bool {
	if value == nil {
		return false
	}
	boolVal, isBool := value.(bool)
	if isBool {
		return boolVal
	}
	strVal, isString := value.(string)
	if isString {
		return len(strVal) > 0
	}
	number, isNumber := value.(float64)
	if isNumber {
		return -1e-9 > number || number > 1e-9
	}
	return false
}

func stringify(value any) string {
	if value == nil {
		return "nil"
	}
	return fmt.Sprint(value)
}
